/* File generated with Shader Minifier 1.1.4
 * http://www.ctrl-alt-test.fr
 */
#ifndef FRAGMENT_SHADER_INL_
# define FRAGMENT_SHADER_INL_

const char *fragment_shader_glsl_pr =
 "#version 430\n"
 "#line 1 0\n"
 "layout(location=0)uniform vec4 fpar[4];"
 "layout(location=0)out vec4 color;"
 "in vec2 p;"
 "vec2 resolution=vec2(1280,720);\n"
 "#define TIME fpar[0].x\nstruct Camera{vec3 position;vec3 forwards;vec3 left;vec3 up;vec3 rayDir;};struct raymarchResult{vec3 position;vec3 diffuse_color;};"
 "float opSmoothUnion(float s,float v,float r)"
 "{"
   "float n=clamp(.5+.5*(v-s)/r,0.,1.);"
   "return mix(v,s,n)-r*n*(1.-n);"
 "}"
 "float sphereSDF(in vec3 v,in vec3 s,in float r)"
 "{"
   "return length(v-s)-r;"
 "}"
 "float sdPlane(vec3 v,vec4 s)"
 "{"
   "return dot(v,s.xyz)+s.w+sin(v.x/10.)*3.+sin(v.z/10.)*3.;"
 "}"
 "float sdBox(vec3 v,vec3 s)"
 "{"
   "vec3 n=abs(v)-s;"
   "return length(max(n,0.))+min(max(n.x,max(n.y,n.z)),0.);"
 "}"
 "float worldSDF(in vec3 v)"
 "{"
   "float s=0.,n=sdPlane(v,vec4(0,1.,0.,1.)),d=sin(4.*v.x)*sin(4.*v.y)*sin(4.*v.z)*.25+sin(v.x)*sin(v.y)*sin(v.z);"
   "vec3 T=v.xyz;"
   "v.xz=mod(v.xz,vec2(20.,20.))-vec2(10.,10.);"
   "float r=sphereSDF(v,vec3(0.,10-sin(T.x/10.)*3.-sin(T.z/10.),0),4.),i=sphereSDF(v,vec3(-5.,10.-sin(T.x/10.)*3.-sin(T.z/10.)*3.,0.),2.),a=sphereSDF(v,vec3(0.,10.-sin(T.x/10.)*3.-sin(T.z/10.)*3.,5.),2.),f=sphereSDF(v,vec3(0.,10.-sin(T.x/10.)*3.-sin(T.z/10.)*3.,-5.),2.),m=sphereSDF(v,vec3(5.,10.-sin(T.x/10.)*3.-sin(T.z/10.)*3.,0.),2.),l=opSmoothUnion(r,i,sin(TIME)*2.+2.),t=opSmoothUnion(a,f,sin(TIME)*2.+2.);"
   "s=opSmoothUnion(l,t,sin(TIME)*2.+2.);"
   "s=opSmoothUnion(m,s,sin(TIME)*2.+2.);"
   "s=opSmoothUnion(s,n,3.);"
   "s=opSmoothUnion(s,sdBox(v,vec3(1.,10.,1.)),1.5);"
   "return s;"
 "}"
 "const int MAX_STEPS=200;"
 "const float MIN_HIT_DIST=.001,MAX_DIST=1000.;"
 "raymarchResult worldMarch(in vec3 v,in vec3 s)"
 "{"
   "raymarchResult r;"
   "r.diffuse_color=vec3(.5);"
   "for(int n=0;n<MAX_STEPS;n++)"
     "{"
       "float T=worldSDF(v);"
       "if(abs(T)<MIN_HIT_DIST)"
         "{"
           "r.diffuse_color=vec3(1.,smoothstep(.25,.3,distance(vec2(.5,.5),fract(v.xz))),1.);"
           "break;"
         "}"
       "if(length(v)>MAX_DIST)"
         "{"
           "r.diffuse_color=vec3(0.);"
           "break;"
         "}"
       "v+=s*T;"
     "}"
   "r.position=v;"
   "return r;"
 "}"
 "vec3 calcWorldNormal(in vec3 v)"
 "{"
   "const float s=.0001;"
   "const vec2 T=vec2(1,-1);"
   "return normalize(T.xyy*worldSDF(v+T.xyy*s)+T.yyx*worldSDF(v+T.yyx*s)+T.yxy*worldSDF(v+T.yxy*s)+T.xxx*worldSDF(v+T.xxx*s));"
 "}"
 "Camera getCam()"
 "{"
   "Camera v;"
   "vec3 T=vec3(0,12,0);"
   "v.position=vec3(cos(TIME)*10.,15+3.,sin(TIME)*10.);"
   "v.up=vec3(0,1,0);"
   "v.forwards=normalize(T-v.position);"
   "v.left=cross(v.forwards,v.up);"
   "v.up=cross(v.left,v.forwards);"
   "vec3 s=v.position+v.forwards;"
   "vec2 n=2.*gl_FragCoord.xy/resolution.xy-1.;"
   "float r=resolution.x/resolution.y;"
   "vec3 l=s+n.x*v.left*r+n.y*v.up;"
   "v.rayDir=normalize(l-v.position);"
   "return v;"
 "}"
 "void main()"
 "{"
   "Camera v=getCam();"
   "vec3 s=v.rayDir;"
   "raymarchResult T=worldMarch(v.position,v.rayDir);"
   "vec3 n=calcWorldNormal(T.position);"
   "color+=vec4(T.diffuse_color*max(0,dot(n,normalize(vec3(1.,1.,0.))))*vec3(1.,1.,1.),1.);"
   "color+=vec4(T.diffuse_color*max(0,dot(n,normalize(vec3(.1,-1.,.2))))*vec3(.3,.3,.5),0.);"
   "color+=vec4(T.diffuse_color*max(0,dot(n,normalize(vec3(-.9,1.,.2))))*vec3(vec3(abs(sin(TIME)),abs(sin(TIME+1)),abs(sin(TIME+2)))),0.);"
   "vec3 r=normalize(vec3(1,-1,1)),i=reflect(-r,n);"
   "float l=pow(max(0.,dot(i,v.rayDir)),200.);"
   "color.xyz+=vec3(l)*T.diffuse_color;"
 "}";

#endif // FRAGMENT_SHADER_INL_
