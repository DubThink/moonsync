/* File generated with Shader Minifier 1.1.6
 * http://www.ctrl-alt-test.fr
 */
#ifndef FRAGMENT_SHADER_INL_
# define FRAGMENT_SHADER_INL_

const char *fragment_shader_glsl_pr =
 "#version 430\n"
 "#line 1 0\n"
 "layout(location=0)uniform vec4 fpar[4];"
 "layout(location=0)out vec4 color;"
 "in vec2 p;"
 "vec2 resolution=vec2(fpar[0].y,fpar[0].z);\n"
 "#define TIME fpar[0].x\n"
 "vec4 permute(vec4 v)"
 "{"
   "return mod((v*34.+1.)*v,289.);"
 "}"
 "vec4 taylorInvSqrt(vec4 v)"
 "{"
   "return 1.79284-.853735*v;"
 "}"
 "vec3 fade(vec3 v)"
 "{"
   "return v*v*v*(v*(v*6.-15.)+10.);"
 "}"
 "float cnoise(vec3 v)"
 "{"
   "vec3 s=floor(v),f=s+vec3(1.);"
   "s=mod(s,289.);"
   "f=mod(f,289.);"
   "vec3 m=fract(v),n=m-vec3(1.);"
   "vec4 z=vec4(s.x,f.x,s.x,f.x),T=vec4(s.yy,f.yy),d=s.zzzz,x=f.zzzz,i=permute(permute(z)+T),r=permute(i+d),c=permute(i+x),l=r/7.,y=fract(floor(l)/7.)-.5;"
   "l=fract(l);"
   "vec4 w=vec4(.5)-abs(l)-abs(y),o=step(w,vec4(0.));"
   "l-=o*(step(0.,l)-.5);"
   "y-=o*(step(0.,y)-.5);"
   "vec4 t=c/7.,a=fract(floor(t)/7.)-.5;"
   "t=fract(t);"
   "vec4 M=vec4(.5)-abs(t)-abs(a),E=step(M,vec4(0.));"
   "t-=E*(step(0.,t)-.5);"
   "a-=E*(step(0.,a)-.5);"
   "vec3 C=vec3(l.x,y.x,w.x),b=vec3(l.y,y.y,w.y),e=vec3(l.z,y.z,w.z),S=vec3(l.w,y.w,w.w),R=vec3(t.x,a.x,M.x),L=vec3(t.y,a.y,M.y),u=vec3(t.z,a.z,M.z),h=vec3(t.w,a.w,M.w);"
   "vec4 g=taylorInvSqrt(vec4(dot(C,C),dot(e,e),dot(b,b),dot(S,S)));"
   "C*=g.x;"
   "e*=g.y;"
   "b*=g.z;"
   "S*=g.w;"
   "vec4 I=taylorInvSqrt(vec4(dot(R,R),dot(u,u),dot(L,L),dot(h,h)));"
   "R*=I.x;"
   "u*=I.y;"
   "L*=I.z;"
   "h*=I.w;"
   "float D=dot(C,m),F=dot(b,vec3(n.x,m.yz)),B=dot(e,vec3(m.x,n.y,m.z)),P=dot(S,vec3(n.xy,m.z)),N=dot(R,vec3(m.xy,n.z)),U=dot(L,vec3(n.x,m.y,n.z)),k=dot(u,vec3(m.x,n.yz)),H=dot(h,n);"
   "vec3 q=fade(m);"
   "vec4 X=mix(vec4(D,F,B,P),vec4(N,U,k,H),q.z);"
   "vec2 A=mix(X.xy,X.zw,q.y);"
   "float W=mix(A.x,A.y,q.x);"
   "return 2.2*W;"
 "}struct Camera{vec3 position;vec3 forwards;vec3 left;vec3 up;vec3 rayDir;};struct Material{vec3 diffuseColor;float specular;float shininess;};struct raymarchResult{vec3 position;vec3 normal;bool hit;Material material;};struct Light{vec3 position;vec3 color;};"
 "Light sun=Light(vec3(-.3,-.8,.2),vec3(1.,1.,.9));"
 "vec3 light1dir=vec3(.6,-1.,-.2),light2dir=vec3(-.2,-.8,.2);"
 "float opSmoothUnion(float v,float s,float x)"
 "{"
   "float m=clamp(.5+.5*(s-v)/x,0.,1.);"
   "return mix(s,v,m)-x*m*(1.-m);"
 "}"
 "float sphereSDF(in vec3 v,in vec3 x,in float z)"
 "{"
   "return length(v-x)-z;"
 "}"
 "float sdPlane(vec3 v,vec4 m)"
 "{"
   "return dot(v,m.xyz)+m.w;"
 "}"
 "float sdVerticalCapsule(vec3 v,float x,float z)"
 "{"
   "return v.y-=clamp(v.y,0.,x),length(v)-z;"
 "}"
 "float sdBox(vec3 v,vec3 z)"
 "{"
   "vec3 s=abs(v)-z;"
   "return length(max(s,0.))+min(max(s.x,max(s.y,s.z)),0.);"
 "}"
 "float opSubtraction(float v,float m)"
 "{"
   "return max(-v,m);"
 "}"
 "float opSmoothSubtraction(float v,float s,float x)"
 "{"
   "float m=clamp(.5-.5*(s+v)/x,0.,1.);"
   "return mix(s,-v,m)+x*m*(1.-m);"
 "}"
 "float sdCappedCylinder(vec3 v,vec2 z)"
 "{"
   "vec2 s=abs(vec2(length(v.xz),v.y))-z;"
   "return min(max(s.x,s.y),0.)+length(max(s,0.));"
 "}"
 "float sdRoundBox(vec3 v,vec3 x,float z)"
 "{"
   "vec3 s=abs(v)-x;"
   "return length(max(s,0.))-z+min(max(s.x,max(s.y,s.z)),0.);"
 "}"
 "vec3 waterpos[6];"
 "float worldSDF2(in vec3 v)"
 "{"
   "float s=0.;"
   "s=sdPlane(v,vec4(0,1.,0.,1.));"
   "for(int r=0;r<6;r++)"
     "s=opSmoothUnion(s,sphereSDF(v,waterpos[r]*vec3(1,3,1),1),.5);"
   "return s;"
 "}"
 "float worldSDF1(in vec3 v)"
 "{"
   "float s=0.,m=sdPlane(v,vec4(0,1.,0.,1.)),f=sphereSDF(v-vec3(0,20,0),vec3(0),1);"
   "f=opSubtraction(min(sphereSDF(vec3(v.x,v.y-20,abs(v.z)),vec3(.6,.4,.4),.3),sphereSDF(vec3(v.x,v.y-20,v.z),vec3(.6,-.4,0),.4)),f);"
   "f=min(sphereSDF(vec3(v.x,v.y-20,abs(v.z)),vec3(.6,.4,.4),.1),f);"
   "float z=sdBox(v,vec3(36.,22.,16.)),x=sdBox(v,vec3(34.5,35.,14.5)),i=min(sdCappedCylinder(vec3(v.y-6,v.x,mod(v.z+5,10)-5),vec2(4.5,36)),sdCappedCylinder(vec3(mod(v.x+5,10)-5,v.z,v.y-6),vec2(4.5,15)));"
   "i=opSubtraction(i,sdBox(v-vec3(0,8.5,0),vec3(36.,2.5,15.)));"
   "float y=sdCappedCylinder(vec3(mod(v.x,10)-5,v.y,mod(v.z,10)-5),vec2(.4,22));"
   "i=opSmoothUnion(i,y,.5);"
   "vec3 n=v-vec3(0,11,0);"
   "float r=min(sdCappedCylinder(vec3(n.y-6,n.x,mod(n.z+5,10)-5),vec2(4.5,36)),sdCappedCylinder(vec3(mod(n.x+5,10)-5,n.z,n.y-6),vec2(4.5,15)));"
   "r=opSubtraction(r,sdBox(n-vec3(0,10.5,0),vec3(36.,3.5,15.)));"
   "float l=opSmoothUnion(r,i,.5);"
   "l=min(l,sdBox(v+vec3(0,.75,0),vec3(36.,.5,15.)));"
   "l=min(l,min(sdBox(vec3(v.x-0,v.y-12,abs(v.z)-5),vec3(25.,1.,.25)),sdBox(vec3(abs(v.x)-25,v.y-12,v.z),vec3(.25,1.,5))));"
   "s=min(opSubtraction(sdBox(v,vec3(24,35,4.5)),min(l,opSubtraction(x,z))),f);"
   "return s;"
 "}"
 "float worldSDF(in vec3 v)"
 "{"
   "return min(worldSDF1(v),worldSDF2(v));"
 "}"
 "vec3 calcWorldNormal(in vec3 v)"
 "{"
   "const float s=.0001;"
   "const vec2 n=vec2(1.,-1.);"
   "return normalize(n.xyy*worldSDF(v+n.xyy*s)+n.yyx*worldSDF(v+n.yyx*s)+n.yxy*worldSDF(v+n.yxy*s)+n.xxx*worldSDF(v+n.xxx*s));"
 "}"
 "const float MIN_HIT_DIST=.01,MAX_DIST=100.,SPEED_MULTIPLIER=1.;"
 "raymarchResult worldMarch(in vec3 v,in vec3 s,const int z)"
 "{"
   "raymarchResult f;"
   "f.material.diffuseColor=vec3(1);"
   "f.hit=true;"
   "for(int r=0;r<z;r++)"
     "{"
       "float m=worldSDF(v);"
       "if(abs(m)<MIN_HIT_DIST)"
         "{"
           "break;"
         "}"
       "if(length(v)>MAX_DIST)"
         "{"
           "f.hit=false;"
           "break;"
         "}"
       "v+=s*m*SPEED_MULTIPLIER;"
     "}"
   "f.position=v;"
   "f.normal=calcWorldNormal(v);"
   "if(worldSDF2(v)<MIN_HIT_DIST)"
     "f.material.shininess=.8;"
   "else"
     " f.material.shininess=.2,f.material.diffuseColor=vec3(.1);"
   "return f;"
 "}"
 "float worldShadow(in vec3 v,in vec3 s,float x,const int z)"
 "{"
   "v+=s*MIN_HIT_DIST*30.;"
   "float r=1.,f=0.,m=1e+20;"
   "for(int l=0;l<z;l++)"
     "{"
       "float n=worldSDF(v),y=n*n/(2.*m),i=sqrt(n*n-y*y);"
       "r=min(r,x*i/max(0.,f-y));"
       "if(n<MIN_HIT_DIST)"
         "return 0.;"
       "if(length(v)>MAX_DIST)"
         "{"
           "break;"
         "}"
       "v+=s*n;"
       "f+=n;"
       "m=n;"
     "}"
   "return r;"
 "}"
 "vec3 skyColor(in vec3 v)"
 "{"
   "float s=abs(dot(v,vec3(0,1,0))),m=max(0,cnoise(v*vec3(2,6,2)+vec3(TIME*.1))+cnoise(5*v*vec3(2,6,2)+vec3(TIME*.1))*.2);"
   "return mix(vec3(.4,.5,1.),vec3(.5,.5,1.),s)+m*s;"
 "}"
 "vec3 render2(in vec3 v,in vec3 s)"
 "{"
   "raymarchResult m=worldMarch(v,s,100);"
   "if(!m.hit)"
     "return skyColor(s);"
   "vec3 r=m.material.diffuseColor,f,n=sun.color*max(vec3(0.),dot(-normalize(sun.position),m.normal));"
   "n*((sin(m.position.x)+sin(m.position.x)+sin(m.position.x))*.2+.8);"
   "f+=vec3(worldShadow(m.position,-sun.position,200.,200))*n;"
   "return f;"
 "}"
 "vec3 render(in vec3 v,in vec3 s)"
 "{"
   "raymarchResult m=worldMarch(v,s,200);"
   "if(!m.hit)"
     "return skyColor(s);"
   "vec3 r=m.material.diffuseColor,f=r*.8*(max(0,dot(m.normal,vec3(0,.7,.7)))+max(0,dot(m.normal,vec3(0,-.7,.7)))+max(0,dot(m.normal,vec3(.4,.3,-.7))))*vec3(.7,.5,1),n=sun.color*max(vec3(0.),dot(-normalize(sun.position),m.normal));"
   "n*((sin(m.position.x)+sin(m.position.x)+sin(m.position.x))*.2+.8);"
   "f+=vec3(worldShadow(m.position,-sun.position,200.,200))*n;"
   "if(m.material.shininess>.5)"
     "{"
       "m.normal=normalize(m.normal+vec3(cnoise(vec3(m.position.xz*.5,TIME*.4)),0,0)*.08+vec3(cnoise(vec3(m.position.xz*2,TIME)),0,0)*.03);"
       "vec3 x=render2(m.position+m.normal*.01,reflect(s,m.normal))*.8*vec3(.7,.9,1.)*(1.1-dot(m.normal,normalize(v-m.position)))*m.material.shininess;"
       "f=mix(f,x,m.material.shininess);"
     "}"
   "return f;"
 "}"
 "Camera getCam()"
 "{"
   "Camera v;"
   "vec3 s=vec3(0,-12,0);"
   "v.position=fpar[1].xyz;"
   "v.up=vec3(0,1,0);"
   "v.forwards=normalize(fpar[2].xyz);"
   "v.left=normalize(cross(v.forwards,v.up));"
   "v.up=normalize(cross(v.left,v.forwards));"
   "vec3 m=v.position+v.forwards;"
   "vec2 n=2.*gl_FragCoord.xy/resolution.xy-1.;"
   "float r=resolution.x/resolution.y;"
   "vec3 l=m+n.x*v.left*r+n.y*v.up;"
   "v.rayDir=normalize(l-v.position);"
   "return v;"
 "}"
 "void main()"
 "{"
   "for(int v=0;v<6;v++)"
     "waterpos[v]=vec3(cnoise(vec3(v,TIME*2,0)),cnoise(vec3(v,TIME*2,10)),cnoise(vec3(v,TIME*2,20)));"
   "Camera v=getCam();"
   "color=vec4(render(v.position,v.rayDir),1.);"
 "}";

#endif // FRAGMENT_SHADER_INL_
