/* File generated with Shader Minifier 1.1.6
 * http://www.ctrl-alt-test.fr
 */
#ifndef FRAGMENT_SHADER_INL_
# define FRAGMENT_SHADER_INL_

const char *fragment_shader_glsl_pr =
 "#version 440\n"
 "#line 1 0\n"
 "layout(location=0)uniform vec4 fpar[4];"
 "layout(location=0)out vec4 color;"
 "in vec2 p;struct Light{vec4 position;vec4 color;};\n"
 "#define NR_LIGHTS 8\nlayout(std140, binding = 0) uniform LightBlock{Light lights[NR_LIGHTS];};struct Ball{vec4 position;vec4 velocity;};\n"
 "#define NR_BALLS 16\nlayout(std140, binding = 1) uniform BallBlock{Ball balls[NR_BALLS];};struct Enemy{vec4 position;vec4 other;};\n"
 "#define NR_ENEMIES 8\nlayout(std140, binding = 2) uniform EnemyBlock{Enemy enemies[NR_ENEMIES];};\n"
 "#define PROJECTILE_OFFSET 4\n"
 "vec2 resolution=vec2(fpar[0].y,fpar[0].z);\n"
 "#define TIME fpar[0].x\nstruct Camera{vec3 position;vec3 forwards;vec3 left;vec3 up;vec3 rayDir;};struct Material{vec3 diffuseColor;float specular;float shininess;vec3 emission;};struct raymarchResult{vec3 position;vec3 normal;bool hit;Material material;};"
 "Light sun=Light(vec4(-.3,-.8,.2,1.),vec4(1.,1.,.9,-1.)*.5);"
 "vec4 permute(vec4 v)"
 "{"
   "return mod((v*34.+1.)*v,289.);"
 "}"
 "vec4 taylorInvsqrt(vec4 v)"
 "{"
   "return 1.79284-.853735*v;"
 "}"
 "vec3 fade(vec3 v)"
 "{"
   "return v*v*v*(v*(v*6.-15.)+10.);"
 "}"
 "float cnoise(vec3 v)"
 "{"
   "vec3 s=floor(v),f=s+vec3(1.);"
   "s=mod(s,289.);"
   "f=mod(f,289.);"
   "vec3 m=fract(v),n=m-vec3(1.);"
   "vec4 i=vec4(s.x,f.x,s.x,f.x),z=vec4(s.yy,f.yy),T=s.zzzz,r=f.zzzz,c=permute(permute(i)+z),d=permute(c+T),a=permute(c+r),l=d/7.,y=fract(floor(l)/7.)-.5;"
   "l=fract(l);"
   "vec4 x=vec4(.5)-abs(l)-abs(y),E=step(x,vec4(0.));"
   "l-=E*(step(0.,l)-.5);"
   "y-=E*(step(0.,y)-.5);"
   "vec4 w=a/7.,e=fract(floor(w)/7.)-.5;"
   "w=fract(w);"
   "vec4 g=vec4(.5)-abs(w)-abs(e),o=step(g,vec4(0.));"
   "w-=o*(step(0.,w)-.5);"
   "e-=o*(step(0.,e)-.5);"
   "vec3 b=vec3(l.x,y.x,x.x),t=vec3(l.y,y.y,x.y),M=vec3(l.z,y.z,x.z),S=vec3(l.w,y.w,x.w),C=vec3(w.x,e.x,g.x),R=vec3(w.y,e.y,g.y),L=vec3(w.z,e.z,g.z),u=vec3(w.w,e.w,g.w);"
   "vec4 N=taylorInvsqrt(vec4(dot(b,b),dot(M,M),dot(t,t),dot(S,S)));"
   "b*=N.x;"
   "M*=N.y;"
   "t*=N.z;"
   "S*=N.w;"
   "vec4 B=taylorInvsqrt(vec4(dot(C,C),dot(L,L),dot(R,R),dot(u,u)));"
   "C*=B.x;"
   "L*=B.y;"
   "R*=B.z;"
   "u*=B.w;"
   "float h=dot(b,m),D=dot(t,vec3(n.x,m.yz)),F=dot(M,vec3(m.x,n.y,m.z)),H=dot(S,vec3(n.xy,m.z)),X=dot(C,vec3(m.xy,n.z)),P=dot(R,vec3(n.x,m.y,n.z)),O=dot(L,vec3(m.x,n.yz)),k=dot(u,n);"
   "vec3 Y=fade(m);"
   "vec4 U=mix(vec4(h,D,F,H),vec4(X,P,O,k),Y.z);"
   "vec2 G=mix(U.xy,U.zw,Y.y);"
   "float q=mix(G.x,G.y,Y.x);"
   "return 2.2*q;"
 "}"
 "const vec3 I=vec3(1,0,0),J=vec3(0,1,0);"
 "mat3 rotateY(float v)"
 "{"
   "float s=cos(v),z=sin(v);"
   "return mat3(vec3(s,0,z),vec3(0,1,0),vec3(-z,0,s));"
 "}"
 "mat3 rotateX(float v)"
 "{"
   "float z=cos(v),y=sin(v);"
   "return mat3(vec3(1,0,0),vec3(0,z,-y),vec3(0,y,z));"
 "}"
 "mat3 pointatY(in vec3 v)"
 "{"
   "float s=dot(normalize(-v.xz),I.xy),y=dot(normalize(-vec2(v.z,-v.x)),I.xy);"
   "mat3 r=mat3(s,0,y,0,1,0,-y,0,s);"
   "return r;"
 "}"
 "mat3 pointatX(in vec3 v)"
 "{"
   "v=normalize(v);"
   "float s=asin(v.y);"
   "mat3 r=mat3(cos(s),-sin(s),0,sin(s),cos(s),0,0,0,1);"
   "return r;"
 "}"
 "float opSmoothUnion(float v,float s,float z)"
 "{"
   "float m=clamp(.5+.5*(s-v)/z,0.,1.);"
   "return mix(s,v,m)-z*m*(1.-m);"
 "}"
 "float sphereSDF(in vec3 v,in vec3 s,in float z)"
 "{"
   "return v-=s,sqrt(dot(v,v))-z;"
 "}"
 "float sdPlane(vec3 v,vec4 s)"
 "{"
   "return dot(v,s.xyz)+s.w;"
 "}"
 "float sdVerticalCapsule(vec3 v,float z,float s)"
 "{"
   "return v.y-=clamp(v.y,0.,z),length(v)-s;"
 "}"
 "float sdBox(vec3 v,vec3 z)"
 "{"
   "vec3 s=abs(v)-z;"
   "return length(max(s,0.))+min(max(s.x,max(s.y,s.z)),0.);"
 "}"
 "float opSubtraction(float v,float s)"
 "{"
   "return max(-v,s);"
 "}"
 "float sdCapsule(vec3 v,vec3 s,vec3 m,float z)"
 "{"
   "vec3 i=v-s,y=m-s;"
   "float r=clamp(dot(i,y)/dot(y,y),0.,1.);"
   "return length(i-y*r)-z;"
 "}"
 "float opSmoothSubtraction(float v,float s,float z)"
 "{"
   "float m=clamp(.5-.5*(s+v)/z,0.,1.);"
   "return mix(s,-v,m)+z*m*(1.-m);"
 "}"
 "float sdCappedCylinder(vec3 v,vec2 z)"
 "{"
   "vec2 s=abs(vec2(length(v.xz),v.y))-z;"
   "return min(max(s.x,s.y),0.)+length(max(s,0.));"
 "}"
 "float sdRoundBox(vec3 v,vec3 s,float z)"
 "{"
   "vec3 l=abs(v)-s;"
   "return length(max(l,0.))-z+min(max(l.x,max(l.y,l.z)),0.);"
 "}"
 "vec3 gunDir;"
 "float sdGun1(in vec3 v)"
 "{"
   "vec3 s=fpar[1].xyz;"
   "v-=s;"
   "v=v*pointatY(gunDir);"
   "v=v*pointatX(gunDir+vec3(0,fpar[3].z,0));"
   "v+=vec3(.6,.4,.35);"
   "float r=sdCappedCylinder(vec3(v.y,v.x,abs(v.z)-.1),vec2(.1,.5));"
   "return r;"
 "}"
 "float sdGun2(in vec3 v)"
 "{"
   "vec3 s=fpar[1].xyz;"
   "v-=s;"
   "v=v*pointatY(gunDir);"
   "v=v*pointatX(gunDir+vec3(0,fpar[3].z,0));"
   "v+=vec3(.6,.4,.35);"
   "v=v*rotateX(fpar[3].y);"
   "float r=opSmoothUnion(sdCappedCylinder(vec3(v.y,v.x,v.z),vec2(.15,.05)),sdCappedCylinder(vec3(v.y,v.x-.3,v.z),vec2(.1,.3)),.1);"
   "r=min(min(r,sdVerticalCapsule(vec3(v.y+.15,v.x+.2,v.z),.2,.025)),sdVerticalCapsule(vec3(v.y-.15,v.x+.2,v.z),.2,.025));"
   "return r;"
 "}"
 "vec3 laserWoggle;"
 "float sdLaser(in vec3 v)"
 "{"
   "if(fpar[3].x>.5||lights[2].color.w<1.)"
     "return 100;"
   "vec3 s=fpar[1].xyz;"
   "v-=s;"
   "v=v*pointatY(gunDir);"
   "v=v*pointatX(gunDir+vec3(0,fpar[3].z,0));"
   "v+=vec3(.6,.4,.35);"
   "return sdCapsule(v,vec3(.5f,0.f,0),vec3(-15.f,0,0)+laserWoggle*.2,.03);"
 "}"
 "vec3 waterpos[4];"
 "float worldSDF2(in vec3 v)"
 "{"
   "float s=0.;"
   "s=sdPlane(v,vec4(0,1.,0.,1.));"
   "if(length(v.xz)>4)"
     "return min(length(v.xz),s);"
   "for(int r=0;r<4;r++)"
     "s=opSmoothUnion(s,sphereSDF(v,waterpos[r]*vec3(1,10,1),1),.5);"
   "return s;"
 "}"
 "float sdEnemy(in vec3 v,in vec3 s,float z)"
 "{"
   "vec3 i=normalize(s-fpar[1].xyz);"
   "v-=s;"
   "v=v*pointatY(i);"
   "v=v*pointatX(i);"
   "float r=sphereSDF(v,vec3(0),min(1,z));"
   "r=opSmoothSubtraction(min(sphereSDF(vec3(v.x,v.y,abs(v.z)),vec3(.6,.3,.4),.3),sphereSDF(vec3(v.x,v.y,v.z),vec3(.6,-.3,0),.4+max(0,z-1))),r,.1);"
   "return min(sphereSDF(vec3(v.x,v.y,abs(v.z)),vec3(.6,.3,.4),min(.1,z-.9)),r);"
 "}"
 "float visuals(in vec3 v)"
 "{"
   "float s=sdCappedCylinder(vec3(abs(v.x)-19,v.y,abs(v.z)-10),vec2(3,1));"
   "return s;"
 "}"
 "float superVisuals(in vec3 v)"
 "{"
   "float s=sphereSDF(v,vec3(0,1.5,15),fpar[0].w*.7);"
   "return s;"
 "}"
 "float worldSDF1(in vec3 v)"
 "{"
   "float s=0.,r=sdPlane(v,vec4(0,1.,0.,2.));"
   "vec3 f,z;"
   "float m=sdBox(v,vec3(35.5,18.,35.5)),i=sdBox(v,vec3(34.5,40.,34.5)),y=min(sdCappedCylinder(vec3(v.y-6,v.x,mod(v.z+5,10)-5),vec2(4.5,36)),sdCappedCylinder(vec3(mod(v.x+5,10)-5,v.z,v.y-6),vec2(4.5,36)));"
   "y=opSubtraction(y,sdBox(v-vec3(0,8.5,0),vec3(36.,2.5,36.)));"
   "float x=sdCappedCylinder(vec3(mod(v.x,10)-5,v.y,mod(v.z,10)-5),vec2(.4,22));"
   "y=opSmoothUnion(y,x,.5);"
   "f=v-vec3(0,11,0);"
   "float l=min(sdCappedCylinder(vec3(f.y-6,f.x,mod(f.z+5,10)-5),vec2(4.5,36)),sdCappedCylinder(vec3(mod(f.x+5,10)-5,f.z,f.y-6),vec2(4.5,36)));"
   "l=opSubtraction(l,sdBox(f-vec3(0,10.5,0),vec3(25.5,3.5,25.5)));"
   "float w=opSmoothUnion(l,y,.5);"
   "w=min(w,sdBox(v+vec3(0,.75,0),vec3(40.,.5,40.)));"
   "w=min(w,min(sdBox(vec3(v.x-0,v.y-12,abs(v.z)-5),vec3(25.,1.,.25)),sdBox(vec3(abs(v.x)-25,v.y-12,v.z),vec3(.25,1.,5))));"
   "s=min(opSubtraction(min(sdBox(v-vec3(0,12,0),vec3(24.5,12.25,14.5)),sdBox(v,vec3(15,35,4))),min(w,opSubtraction(i,m))),visuals(v));"
   "return s;"
 "}"
 "float enemiesSDF(in vec3 v)"
 "{"
   "float s=1000.;"
   "for(int r=PROJECTILE_OFFSET;r<PROJECTILE_OFFSET+4;r++)"
     "s=min(s,sphereSDF(v,balls[r].position.xyz,balls[r].position.w));"
   "for(int r=0;r<NR_ENEMIES;r++)"
     "{"
       "if(length(v-enemies[r].position.xyz)>3)"
         "s=min(s,length(v-enemies[r].position.xyz)-2);"
       "else"
         " s=min(sdEnemy(v,enemies[r].position.xyz,enemies[r].position.w),s);"
     "}"
   "return s;"
 "}"
 "float worldSDF3(in vec3 v)"
 "{"
   "float s=1000.;"
   "for(int r=1;r<PROJECTILE_OFFSET;r++)"
     "s=min(s,sphereSDF(v,balls[r].position.xyz,.5));"
   "return min(s,enemiesSDF(v));"
 "}"
 "float sdOmnibar(in vec3 v)"
 "{"
   "vec3 s=fpar[1].xyz;"
   "float r=100;"
   "r=min(sphereSDF(v,vec3(20,1.5,0),fpar[1].w),sphereSDF(v,vec3(-20,1.5,0),fpar[2].w*.4));"
   "v-=s;"
   "v=v*pointatY(fpar[2].xyz);"
   "v=v*pointatX(fpar[2].xyz);"
   "v+=vec3(.5,-.35,-.4*(1-fpar[3].w));"
   "r=min(r,sdCappedCylinder(vec3(v.x,v.z,v.y),vec2(.007,.4*fpar[3].w)));"
   "return r;"
 "}"
 "float viewmodelSDFReflective(in vec3 v)"
 "{"
   "if(fpar[3].x>.5)"
     "return sdGun1(v);"
   "return sdGun2(v);"
 "}"
 "float viewmodelSDF(in vec3 v)"
 "{"
   "return min(min(viewmodelSDFReflective(v),sdOmnibar(v)),sdLaser(v));"
 "}"
 "float worldSDF(in vec3 v)"
 "{"
   "return min(min(worldSDF1(v),viewmodelSDF(v)),min(worldSDF2(v),worldSDF3(v)));"
 "}"
 "float shadowSDF(in vec3 v)"
 "{"
   "return min(worldSDF1(v),worldSDF2(v));"
 "}"
 "vec3 calcWorldNormal(in vec3 v)"
 "{"
   "const float s=.0001;"
   "const vec2 l=vec2(1.,-1.);"
   "return normalize(l.xyy*worldSDF(v+l.xyy*s)+l.yyx*worldSDF(v+l.yyx*s)+l.yxy*worldSDF(v+l.yxy*s)+l.xxx*worldSDF(v+l.xxx*s));"
 "}"
 "const float MIN_HIT_DIST=.01,MAX_DIST=100.,SPEED_MULTIPLIER=1.;"
 "raymarchResult worldMarch(in vec3 v,in vec3 s,const int z)"
 "{"
   "raymarchResult f;"
   "f.material.diffuseColor=vec3(1);"
   "f.material.specular=3.;"
   "f.material.emission=vec3(0);"
   "f.hit=true;"
   "for(int r=0;r<z;r++)"
     "{"
       "float i=worldSDF(v);"
       "if(i<MIN_HIT_DIST)"
         "{"
           "break;"
         "}"
       "if(length(v)>MAX_DIST)"
         "{"
           "f.hit=false;"
           "break;"
         "}"
       "v+=s*i*SPEED_MULTIPLIER;"
     "}"
   "f.position=v;"
   "f.normal=calcWorldNormal(v);"
   "if(worldSDF2(v)<MIN_HIT_DIST)"
     "f.material.diffuseColor=vec3(.7,.7,1.),f.material.shininess=.8;"
   "if(worldSDF2(v)<MIN_HIT_DIST)"
     "f.material.diffuseColor=vec3(1.,.1,.1),f.material.shininess=.8;"
   "else"
     " if(viewmodelSDFReflective(v)<MIN_HIT_DIST)"
       "f.material.diffuseColor=vec3(.4,.5,1.2),f.material.shininess=.6;"
     "else"
       " if(sdLaser(v)<MIN_HIT_DIST)"
         "f.material.emission=vec3(3,3,5);"
       "else"
         " if(sdOmnibar(v)<MIN_HIT_DIST)"
           "f.material.diffuseColor=vec3(.2,1.,.7),f.material.shininess=.6,f.material.emission=vec3(0,.3,0);"
         "else"
           " if(visuals(v)<MIN_HIT_DIST)"
             "f.material.diffuseColor=vec3(.3,1.,1.);"
           "else"
             " if(enemiesSDF(v)<MIN_HIT_DIST)"
               "f.material.diffuseColor=vec3(1.,.2,.2),f.material.emission=vec3(.15,0.,0.);"
             "else"
               " f.material.shininess=.2,f.material.diffuseColor=vec3(.8);"
   "return f;"
 "}"
 "float worldShadow(in vec3 v,in vec3 s,float z,const int r)"
 "{"
   "v+=s*MIN_HIT_DIST*30.;"
   "float f=1.,y=0.,m=1e+20;"
   "for(int i=0;i<r;i++)"
     "{"
       "float l=shadowSDF(v),w=l*l/(2.*m),d=sqrt(l*l-w*w);"
       "f=min(f,z*d/max(0.,y-w));"
       "if(l<MIN_HIT_DIST)"
         "return 0.;"
       "if(length(v)>MAX_DIST)"
         "{"
           "break;"
         "}"
       "v+=s*l;"
       "y+=l;"
       "m=l;"
     "}"
   "return f;"
 "}"
 "float pointShadow(in vec3 v,in vec3 s,float z,const int r)"
 "{"
   "vec3 m=-normalize(s);"
   "v+=m*MIN_HIT_DIST*30.;"
   "float f=1.,i=0.,y=1e+20;"
   "for(int l=0;l<r;l++)"
     "{"
       "float w=shadowSDF(v),T=w*w/(2.*y),d=sqrt(w*w-T*T);"
       "f=min(f,z*d/max(0.,i-T));"
       "if(w<MIN_HIT_DIST)"
         "return 0.;"
       "if(i>length(s))"
         "{"
           "break;"
         "}"
       "v+=m*w;"
       "i+=w;"
       "y=w;"
     "}"
   "return f;"
 "}"
 "vec3 skyColor(in vec3 v)"
 "{"
   "float s=abs(dot(v,vec3(0,1,0))),f=max(0,cnoise(v*vec3(2,6,2)+vec3(TIME*.1))+cnoise(5*v*vec3(2,6,2)+vec3(TIME*.1))*.2);"
   "return mix(vec3(.4,.5,1.),vec3(.5,.5,1.),s)+f*s;"
 "}"
 "vec3 render2(in vec3 v,in vec3 s)"
 "{"
   "raymarchResult f=worldMarch(v,s,50);"
   "if(!f.hit)"
     "return skyColor(s);"
   "vec3 m=f.material.diffuseColor,r=m*.17*(max(0,dot(f.normal,vec3(0,.7,.7)))+max(0,dot(f.normal,vec3(0,-.7,.7)))+max(0,dot(f.normal,vec3(.4,.3,-.7))))*vec3(.7,.5,1),z;"
   "float i;"
   "z=f.position-lights[2].position.xyz+lights[2].position.w*vec3(cnoise(vec3(TIME*100))*.3,cnoise(vec3(TIME*100*200))*.3,cnoise(vec3(TIME*100+100))*.3);"
   "i=length(z);"
   "if(lights[2].position.w>.1&&i<50)"
     "{"
       "vec3 w=lights[2].color.w*lights[2].color.xyz*max(0,dot(f.normal,-z/pow(i,1.3)))*(1+lights[2].position.w*cnoise(vec3(TIME*100)));"
       "r+=w*vec3(pointShadow(f.position.xyz,z,60.,50));"
     "}"
   "vec3 w=sun.color.xyz*max(vec3(0.),dot(-normalize(sun.position.xyz),f.normal));"
   "r+=vec3(worldShadow(f.position.xyz,-sun.position.xyz,200.,50))*w;"
   "r+=f.material.emission;"
   "return r;"
 "}"
 "vec3 render(in vec3 v,in vec3 s)"
 "{"
   "raymarchResult f=worldMarch(v,s,100);"
   "if(!f.hit)"
     "return skyColor(s);"
   "vec3 m=f.material.diffuseColor,r=m*.17*(max(0,1.3*dot(f.normal,vec3(0,.7,.2)))+max(0,dot(f.normal,vec3(0,-.7,.7)))+max(0,dot(f.normal,vec3(.4,.3,-.7))))*vec3(.7,.5,1),y=reflect(s,f.normal),z=sun.color.xyz*max(vec3(0.),dot(-normalize(sun.position.xyz),f.normal));"
   "float w=worldShadow(f.position.xyz,-sun.position.xyz,40.,100);"
   "r+=w*z;"
   "vec3 i;"
   "float l;"
   "for(int e=0;e<2;e++)"
     "{"
       "i=f.position-lights[e].position.xyz;"
       "l=length(i);"
       "if(l>50)"
         "continue;"
       "vec3 E=lights[e].color.xyz*max(vec3(0),dot(f.normal,-i/l));"
       "r+=E*.1;"
     "}"
   "i=f.position-lights[2].position.xyz+lights[2].position.w*vec3(cnoise(vec3(TIME*100))*.3,cnoise(vec3(TIME*100*200))*.3,cnoise(vec3(TIME*100+100))*.3);"
   "l=length(i);"
   "if(lights[2].position.w>.1&&l<50)"
     "{"
       "vec3 E=lights[2].color.w*lights[2].color.xyz*max(0,dot(f.normal,-i/pow(l,1.3)))*(1+lights[2].position.w*cnoise(vec3(TIME*100)));"
       "r+=E*vec3(pointShadow(f.position.xyz,i,60.,100));"
     "}"
   "if(f.material.shininess>.5)"
     "{"
       "f.normal=normalize(f.normal+vec3(cnoise(vec3(f.position.xz*.5,TIME*.4)),0,0)*.08+vec3(cnoise(vec3(f.position.xz*2,TIME)),0,0)*.03);"
       "vec3 x=render2(f.position+f.normal*.01,reflect(s,f.normal))*.8*vec3(.7,.9,1.)*(1.1-dot(f.normal,normalize(v-f.position)))*f.material.shininess;"
       "r=mix(r,x,f.material.shininess);"
     "}"
   "r+=f.material.emission;"
   "return r;"
 "}"
 "Camera getCam()"
 "{"
   "Camera v;"
   "vec3 s=vec3(0,-12,0);"
   "v.position=fpar[1].xyz;"
   "v.up=vec3(0,1,0);"
   "v.forwards=normalize(fpar[2].xyz);"
   "v.left=normalize(cross(v.forwards,v.up));"
   "v.up=normalize(cross(v.left,v.forwards));"
   "vec3 r=v.position+v.forwards;"
   "vec2 f=2.*gl_FragCoord.xy/resolution.xy-1.;"
   "f*=.8;"
   "float m=resolution.x/resolution.y;"
   "vec3 i=r+f.x*v.left*m+f.y*v.up;"
   "v.rayDir=normalize(i-v.position);"
   "return v;"
 "}"
 "void main()"
 "{"
   "gunDir=normalize(fpar[2].xyz+sin(vec3(TIME*.2,TIME*2.709,TIME*3.41))*.01);"
   "laserWoggle=vec3(cnoise(vec3(TIME*100))*.3,cnoise(vec3(TIME*100*200))*.3,cnoise(vec3(TIME*100+100)));"
   "for(int v=0;v<6;v++)"
     "waterpos[v]=vec3(cnoise(vec3(v,TIME*.4,0)),cnoise(vec3(v,TIME*.4,10)),cnoise(vec3(v,TIME*.4,20)));"
   "Camera v=getCam();"
   "color=vec4(render(v.position,v.rayDir),1.);"
 "}";

#endif // FRAGMENT_SHADER_INL_
